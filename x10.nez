/* Toplevel */
File                      = _ CompilationUnit !.
CompilationUnit           = { $(PackageDeclaration)? _ $(ImportDeclarations)? _ $(PackageDeclaration)? _ $(ImportDeclarations)? _ $(TypeDeclarations)? _ #Source }


/* Code layout */
_                         = ( WHITESPACE / BLOCKCOMMENT / LINECOMMENT )*
WHITESPACE                = [ \t\f\r\n]
BLOCKCOMMENT              = '/*' ( !'*/' . )* '*/'
LINECOMMENT               = '//' ( ![\r\n] . )*
W                         = [a-zA-Z_0-9]

/* Declarations */
PackageDeclaration        = { ($(Annotations) _)? "package" _ $(PackageName) _ ';' #PackageDeclaration }
PackageName               = Identifier {$ '.' $(Identifier) #PackageName }*
ImportDeclarations        = { $(ImportDeclaration) (_ $(ImportDeclaration) )* #ImportDeclarations }
ImportDeclaration         = { $(TypeImportOnDemandDecln) #ImportDeclaration }
                          / { $(SingleTypeImportDecln) #ImportDeclaration }
TypeImportOnDemandDecln   = { "import" _ $(PackageOrTypeName) '.*' _ ';' #TypeImportOnDemandDeclaration }
PackageOrTypeName         = Identifier {$ '.' $(Identifier) #PackageOrTypeName }*
SingleTypeImportDecln     = { "import" _ $(TypeName) _ ';' #SingleTypeImportDeclaration }

TypeDeclarations          = { $(TypeDeclaration) (_ $(TypeDeclaration) )* #TypeDeclarations }
TypeDeclaration           = ClassDeclaration
                          / StructDeclaration
                          / InterfaceDeclaration
                          / TypeDefDeclaration
                          / ';'
ClassDeclaration          = { ($(Mods) _)? "class" _ $(Identifier) (_ $(TypeParametersI))? (_ $(Properties))? (_ $(Guard))? (_ $(Super))? (_ $(Interfaces))? _ $(ClassBody) #ClassDeclaration }
Mods                      = { $(Mod) (_ $(Mod))* #Mods }
Mod                       = { "abstract" #Abstruact }
                          / Annotations
                          / { "atomic" #Atomic }
                          / { "final" #Final }
                          / { "native" #Native }
                          / { "private" #Private }
                          / { "protected" #Protected }
                          / { "public" #Public }
                          / { "static" #Static }
                          / { "transient" #Transient}
                          / { "clocked" #Clocked }
Properties                = {'(' _ PropList _ ')' #Properties }
PropList                  = $(Prop) (_ $(Prop))*
Prop                      = { ($(Annotations) _)? $(Identifier) _ $(ResultType) #Prop }
ResultType                = { ':' _ $(Type) #ResultType }
Guard                     = { '{' _ $(DepParams) _ '}' #Guard }
Super                     = { "extends" _ $(ClassType) #Super }
Interfaces                = { "implements" _ $(InterfaceTypeList) #Interfaces }
ClassBody                 = { '{' (_ $(ClassMemberDeclns))? _ '}' #ClassBody }
ClassMemberDeclns         = { $(ClassMemberDecln) (_ $(ClassMemberDecln))* #ClassMemberDeclns }
ClassMemberDecln          = InterfaceMemberDecln
                          / ConstructorDeclaration
InterfaceMemberDecln      = MethodDeclaration
                          / PropertyMethodDeclaration
                          / FieldDeclaration
                          / TypeDeclaration
TypeDeclaration           = ClassDeclaration
                          / StructDeclaration
                          / InterfaceDeclaration
                          / TypeDefDeclaration
                          / ';'
StructDeclaration         = { ($(Mods) _)? "struct" _ $(Identifier) (_ $(TypeParametersI))? (_ $(Properties))? (_ $(Guard))? (_ $(Interfaces))? _ $(ClassBody) #StructDeclaration }
InterfaceDeclaration      = { ($(Mods) _)? "interface" _ $(Identifier)  (_ $(TypeParametersI))? (_ $(Properties))? (_ $(Guard))? (_ $(Interfaces))? (_ $(ExtendsInterfaces))? _ $(InterfaceBody) #InterfaceDeclaration }
ExtendsInterfaces         = { "extends" _ $(Type) (_ ',' _ $(Type))* #ExtendsInterfaces }
InterfaceBody             = { '{' (_  $(InterfaceMemberDecln))? _ '}' #InterfaceBody }
TypeDefDeclaration        = { ($(Mods) _)? "type" _ $(Identifier) (_ $(TypeParameters))? (_ '(' _ FormalList _ ')')? (_ $(Guard))? _ '=' _ $(Type) _ ';' #TypeDefDeclaration }
MethodDeclaration         = { ($(MethodMods) _)? "def" _ $(Identifier) (_ $(TypeParameters))? _ $(Formals) (_ $(Guard))? (_ $(Throws))? (_ $(HasResultType))? _ $(MethodBody) #MethodDeclaration }
                          / BinOpDecln
                          / PrefixOpDecln
                          / ApplyOpDecln
                          / SetOpDecln
                          / ConversionOpDecln
BinOpDecln                = { $(MethodMods) _ "operator" (_ $(TypeParameters))? _ $(BinOpDeclnInner) (_ $(Guard))? (_ $(HasResultType))? _ $(MethodBody) #BinOpDecln }
BinOpDeclnInner           = { $({ "this" #This }) _ BinOp _ '(' _ $(Formal) _ ')' }
                          / { '(' _ $(Formal) _ ')' _ BinOp _ ('(' _ $(Formal) _ ')' / $({ "this" #This })) }
BinOp                     = "+" #Add
                          / "-"
                          / "*"
                          / "/"
                          / "%"
                          / "&"
                          / "|"
                          / "^"
                          / "&&"
                          / "||"
                          / "<<"
                          / ">>"
                          / ">>>"
                          / ">="
                          / "<="
                          / ">"
                          / "<"
                          / "=="
                          / "!="
                          / ".."
                          / "->"
                          / "<-"
                          / "-<"
                          / ">-"
                          / "**"
                          / "~"
                          / "!~"
                          / "!"
PrefixOpDecln             = { $(MethodMods) _ "operator" (_ $(TypeParameters))? _ $(PrefixOpDeclnInner) (_ $(Guard))? (_ $(HasResultType))? _ $(MethodBody) #PrefixOpDecln }
PrefixOpDeclnInner        = { PrefixOp _ ('(' _ $(Formal) _ ')' / $({ "this" #This })) }
PrefixOp                  = "+" #Plus
                          / "-"
                          / "!"
                          / "~"
                          / "^"
                          / "|"
                          / "&"
                          / "*"
                          / "/"
                          / "%"
ApplyOpDecln              = { $(MethodMods) _ "operator" _ "this" (_ $(TypeParameters))? _ $(Formals) (_ $(Guard))? (_ $(HasResultType))? _ $(MethodBody) #ApplyOpDecln }
SetOpDecln                = { $(MethodMods) _ "operator" _ "this" (_ $(TypeParameters))? _ $(Formals) _ "=" _ '('_ $(Formal) _ ')' (_ $(Guard))? (_ $(HasResultType))? _ $(MethodBody) #SetOpDecln }
ConversionOpDecln         = ExplConvOpDecln
                          / ImplConvOpDecln
ExplConvOpDecln           = { $(MethodMods) _ "operator" (_ $(TypeParameters))? _ '('_ $(Formal) _ ')' _ "as" _ ($(Type) #ExplConvOpDecln / "?" #ExplConvOpDecln) (_ $(Guard))? _ $(MethodBody) }
ImplConvOpDecln           = { $(MethodMods) _ "operator" (_ $(TypeParameters))? _ '('_ $(Formal) _ ')' (_ $(Guard))? (_ $(HasResultType))? _ $(MethodBody) #ImplConvOpDecln }
MethodMods                = { ($({ "property" #Property }) / $(Mod))+ #MethodMods }
Throws                    = { "throws" _ $(ThrowList) #Throws }
ThrowList                 = { $(Type) _ (_ ',' _ $(Type))* #ThrowList }
MethodBody                = { '=' _ $(Expression) _ ';' #MethodBody }
                          / { ($(Annotations) _)? $(Block) #MethodBody }
                          / { ';' #Empty }
ConstructorDeclaration    = { ($(Mods) _)? "def" _ "this" (_ $(TypeParameters))? _ $(Formals) (_ $(Guard))? (_ $(HasResultType))? _ $(ConstructorBody) }
HasResultType             = { '<:' _ $(Type) #HasResultType }
                          / ResultType
ConstructorBody           = { $(ConstructorBlock) }
                          / {'=' _ $(ExplicitCtorInvo)}
                          / {'=' _ $(AssignPropCall)}
                          / { ';' #Empty }
ConstructorBlock          = { '{' (_ $(ExplicitCtorInvo))? (_ _BlockStatements)? _ '}' #ConstructorBlock }
ExplicitCtorInvo          = { ($(PrimaryExpression) '.')? ("this" / "super") (_ $(TypeArguments))? _ '(' (_ $(ArgumentList))? _ ')' _ ';' #ExplicitCtorInvo }
AssignPropCall            = { "property" _ (_ $(TypeArguments))? _ '(' (_ $(ArgumentList))? _ ')' _ ';' #AssignPropCall }
PropertyMethodDeclaration = { ($(MethodMods) _)? _ $(Identifier) ((_ $(TypeParameters))? _ $(Formals))? (_ $(Guard))? (_ $(HasResultType))? _ $(MethodBody) #PropertyMethodDeclaration }
FieldDeclaration          = { ($(Mods) _)? ($(VarKeyword) _ )? $(FieldDeclrs) _ ';' #FieldDeclaration }
FieldDeclrs               = FieldDeclr {$ _ ',' _ $(FieldDeclr) #FieldDeclrs }*
FieldDeclr                = { $(Identifier) (_ $(HasResultType))? _ '=' _ $(Expression) #FieldDeclr }
                          / { $(Identifier) _ $(HasResultType) #FieldDeclr }
LocalVariableDeclaration  = { ($(Mods) _ )? $(VarKeyword) _ ($(VariableDeclrs) #LocalVariableDeclaration / $(FormalDeclrs) #LocalFormalDeclaration) }
                          / { ($(Mods) _ )? $(VarDeclsWType) }
VarDeclsWType              = VarDeclWType {$ _ ',' _ $(VarDeclWType) #VarDeclsWType }*
VarDeclWType               = { (($(Identifier) (_ ('[' $(IdentifierList) ']'))? ) / '[' $(IdentifierList) ']' ) (_ $(HasResultType)) _ "=" _ $(Expression) #VariableDeclr }
VariableDeclrs            = VariableDeclr {$ _ ',' _ $(VariableDeclr) #VariableDeclrs }*
VariableDeclr             = { (($(Identifier) (_ ('[' $(IdentifierList) ']'))? ) / '[' $(IdentifierList) ']' ) (_ $(HasResultType))? _ "=" _ $(Expression) #VariableDeclr }
FormalDeclrs              = FormalDeclr {$ _ ',' _ $(FormalDeclr) #FormalDeclrs }*
FormalDeclr               = { (($(Identifier) (_ ('[' $(IdentifierList) ']'))? ) / '[' $(IdentifierList) ']' ) _ $(ResultType) #FormalDeclr }
Formals                   = { '(' (_ FormalList)? _ ')' #Formals }
FormalList                = $(Formal) (_ ',' _ $(Formal))*
Formal                    = { ($(Mods) _)? (_ $(VarKeyword))? $(FormalDeclaration) #Formal }
                          / Type
VarKeyword                = { "val" #Val }
                          / { "var" #Var }
FormalDeclaration         = { '[' _ $(IdentifierList) _ ']' _ $(ResultType) #FormalDeclaration }
                          / { $(Identifier) ( _ '[' _ $(IdentifierList) _ ']')? _ $(ResultType) #FormalDeclaration }
LoopIndex                 = { ($(Mods) _)? (_ $(VarKeyword))? $(LoopIndexDeclr) #LoopIndex }
LoopIndexDeclr            = { (($(Identifier) (_ ('[' $(IdentifierList) ']'))? ) / '[' $(IdentifierList) ']' ) (_ $(HasResultType))? #LoopIndexDeclr }

example PackageDeclaration '''
package ID.ID;
'''
example ImportDeclarations '''
import Int;
import ID.ID.*;
'''
example TypeDeclaration '''
class ID extends Int implements Int, Int {}
'''
example TypeDeclaration '''
struct ID {}
'''
example TypeDeclaration '''
interface ID extends Int, Int {}
'''
example MethodDeclaration '''
public def ID(ID : Int) : Int {}
'''
example MethodDeclaration '''
public operator !(ID : Int) {}
'''
example PropertyMethodDeclaration '''
property ID(ID : Int) = exp;
'''
example ConstructorDeclaration '''
def this(ID : Int) {}
'''
example ConstructorDeclaration '''
def this(ID : Int) = this();
'''
example ConstructorDeclaration '''
def this(ID : Int) = exp.super();
'''
example FieldDeclaration '''
private var ID : Int = exp;
'''
example LocalVariableDeclaration '''
var ID : Int = exp
'''
example LocalVariableDeclaration '''
val ID = exp
'''
example LocalVariableDeclaration '''
var ID : Int
'''


/* Types */
Type                      = (Void / FunctionType / NamedType) {$ _ $(Annotations) #AnnotatedType }?
Annotations               = { $(Annotation) (_ $(Annotation))* #Annotations }
Annotation                = { '@' _ $(NamedTypeNoConstraints) #Annotation }
Void                      = { "void" #Void }

NamedType                 = NamedTypeNoConstraints {$ _ $(DepParams) #DepNamedType }?

NamedTypeNoConstraints    = TypeName
                            {$ _ ( $(Arguments) /
                                    $(TypeArguments) (_ $(Arguments) )?   ) #ParamizedNamedType }*
                            {$ _ ( _ '.' _ $(Identifier) #SimpleNamedType /
                                    _ $(DepParams) #DepNamedType ) }*

TypeArguments             = { '[' _ $(Type) (_ ',' _ $(Type))* _ ']' #TypeArguments }
ClassType                 = NamedType
InterfaceTypeList         = { _ $(Type) (_ ',' _ $(Type))* _ #InterfaceTypeList }
ThrowsList                = { 'Int, Int' #Stub }

TypeName                  = { $(Identifier) (_ '.' _ $(Identifier))* #TypeName }    //FIXME: self
DepParams                 = { '{' _ $(Expression) _ '}' #DepParams }

FunctionType              = { $(TypeParameters)? _ '(' _ $( { $(Formal) (_ ',' _ $(Formal))* #FormalList } ) _ ')' _ $(Guard)? _ '=>'_ $(Type) #FunctionType }
TypeParameters            = { '[' _ $(TypeParameter) ( _ ',' _ $(TypeParameter) )* _ ']' #TypeParameters }
TypeParameter             = {  $(Identifier) #TypeParameter }
TypeParametersI           = { '[ID,]' #Stub }

example Type Int
example Type ID[ID]
example Type ID[ID,ID]
example Type ID.ID
example Type (ID : Int) => Int


/* Statements */
_BlockStatements          = ($(BlockInteriorStatement) _)*
AnnotatedStatement        = {$ (Annotations)?} Statement
Statement                 = Block
                          / AssertStatement
                          / SwitchStatement
                          / DoStatement
                          / BreakStatement
                          / ContinueStatement
                          / ReturnStatement
                          / ThrowStatement
                          / TryStatement
                          / LabeledStatement
                          / IfThenStatement
                          / WhileStatement
                          / ForStatement
                          / AsyncStatement
                          / AtStatement
                          / AtomicStatement
                          / WhenStatement
                          / AtEachStatement
                          / FinishStatement
                          / AssignPropCall
                          / ExpressionStatement
                          / EmptyStatement
Block                     = { "{" _ $list(BlockStatement)? _ "}"  #Block } _
BlockStatement            = { ($(BlockInteriorStatement) _)* #List} _
BlockInteriorStatement    = LocalVariableDeclarationStatement
                          / ClassDeclaration
                          / StructDeclaration
                          / TypeDefDeclaration
                          / Statement
AtStatement               = { "at" _ "(" _ $(Expression) _ ")" _ $(Statement) #At} _
AsyncStatement            = { "async" _ $(ClockedClause)? $(Statement) #Async} _
                          / { "clocked" _ "async" _ $(Statement) #Async} _
ClockedClause              = { "clocked" _ $(Arguments) #Clocked} _
FinishStatement           = { "finish" _ $(Statement) #Finish} _
                          / { "clocked" _ "finish" _ $(Statement) #ClockedFinish} _
AtEachStatement           = { "ateach" _ "(" _ $(LoopIndex) _ "in" _ $(Expression) ")" _ $(ClockedClause)? $(Statement) #AtEach} _
                          / { "ateach" _ "(" _ $(Expression) _ ")" _ $(Statement) #AtEach} _
AtomicStatement           = { "atomic" _ $(Statement) #Atomic} _
AssignPropCall            = { "property" _ $(TypeArguments)? "(" _ $(Arguments)? ")" #Property} _
WhenStatement             = { "when" _ "(" _ $(Expression) _ ")" _ $(Statement) #When} _
LocalVariableDeclarationStatement = LocalVariableDeclaration _ ";" _
ExpressionStatement       = { $expr(StatementExpression)  #Expression } ";" _
LabeledStatement          = { $(Identifier) _ ":" _ $(Statement) #LabeledStatement} _
BreakStatement            = { "break" _ $id(Identifier)? ";" #Break} _
ContinueStatement         = { "continue" _ $id(Identifier)? #Continue} _
IfThenStatement           = { "if" _ "(" _ $(Expression) ")" _ $(Statement) ("else" _ $(Statement))? #If} _
SwitchStatement           = { "switch" _ "(" _ $cond(Expression) _ ")" _ $body(SwitchBlock) #Switch } _
SwitchBlock               = "{" _ { $(SwitchCondition)+ #Block } "}" _
SwitchCondition           = { "case" _ $cond(Expression) _ ":" _ $body(CaseBlock) #SwitchCase } _
                          / { "default" _ ":" _ $body(CaseBlock) #SwitchDefault } _
CaseBlock                 = { $(BlockStatement)* #Block } _
WhileStatement            = { "while" _ "(" _ $(Expression) _ ")" _ $(Statement) #While } _
DoStatement               = { "do" _ $(Statement) "while" _ "(" _ $(Expression) ")" #DoWhile} _
ForStatement              = BasicForStatement
                          / EnhancedForStatement
BasicForStatement         = { "for" _ "(" _ $(ForInitializer)? ";" _  $(Expression)? ";" _ $(ForUpdater)? ")" _ $(Statement) #For} _
ForInitializer            = StatementExpressionList
                          / LocalVariableDeclaration
ForUpdater                = StatementExpression
EnhancedForStatement      = { "for" _ "(" _ $(LoopIndex) "in" _ $(Expression) "in" _ ")" _ $(Statement) #ForIn } _
                          / { "for" _ "(" _ $(Expression) ")" #For} _
ReturnStatement           = { "return" _ $(Expression)? ";" #Return} _
AssertStatement           = { "assert" _ $(Expression) ";" #Assert} _
                          / { "assert" _ $(Expression) _ ":" _ $(Expression) ";" #Assert} _
ThrowStatement            = { "throw" _ $(Expression) ";" #Throw} _
TryStatement              = { "try" _ $(Block) $list(CatchList)? $(Finally)? #TryCatch} _
CatchList                 = { $(Catch)* #List} _
Catch                     = { "catch" _ "(" _ $(Formals) _ ")" _ $(Block) #Catch} _
Finally                   = { "finally" _ $(Block) #Finally } _
EmptyStatement            = ";" { #Empty} _

example Block {}
example Block '''
{
  class X{}
  var x = 1;
}
'''
example Statement ;
example Statement {}
example Statement exp++;
example Statement break;
example Statement break ID;
example Statement continue;
example Statement if(exp) break;
example Statement while(exp) {}
example Statement do {} while(exp);
example Statement for(var x = 1; exp; exp++) {}
example Statement return exp;
example Statement ID : while(exp) {}
example Statement assert exp;
example Statement assert exp : exp;
example Statement throw exp;
example Statement '''
switch(exp) {
    case exp : break;
    case exp : break;
    default : break;
}
'''
example Statement '''
try {
} catch (ID : Int) {
} catch (ID : Int) {
}
'''
example Statement '''
try {
} finally {
}
'''
example Statement at(exp) {}
example Statement async {}
example Statement async clocked(exp) {}
example Statement clocked async {}
example Statement finish {}
example Statement clocked finish {}
example Statement ateach(li in exp) {}
example Statement ateach(exp) {}
example Statement atomic {}
example Statement when(exp) {}


/* Expressions */
StatementExpressionList   = { $(StatementExpression) (_ "," _ $(StatementExpression))* #List }
StatementExpression       = Expression

Arguments                          = '(' _ ArgumentList _ ')'
ArgumentList                       = { $(Expression) (_ "," _ $(Expression))* #List }
                                   / { '' #List}
Expression                         = AssignmentExpression
AssignmentExpression               = { $left(LeftHandSideExpression) _ _AssignmentOperator _ $right(AssignmentExpression) }
                                   / ConditionalExpression
LeftHandSideExpression             = Identifier
_AssignmentOperator                = "=" #Assign
                                   / "*=" #AssignMul
                                   / "/=" #AssignDiv
                                   / "%=" #AssignMod
                                   / "+=" #AssignAdd
                                   / "-=" #AssignSub
                                   / "<<=" #AssignLeftShift
                                   / ">>=" #AssignArithmeticRightShift
                                   / ">>>=" #AssignLogicalRightShift
                                   / "&=" #AssignBitwiseAnd
                                   / "^=" #AssignBitwiseXOr
                                   / "|=" #AssignBitwiseOr
ConstantExpression                 = ConditionalExpression
ConditionalExpression              = LogicalOrExpression {$cond _ "?" _ $then(Expression) _ ":" _ $else(LogicalOrExpression) #Conditional }*
LogicalOrExpression                = LogicalAndExpression {$left _ "||" _ $right(LogicalAndExpression) #Or }*
LogicalAndExpression               = InclusiveOrExpression {$left _ "&&" _ $right(InclusiveOrExpression) #And }*
InclusiveOrExpression              = ExclusiveOrExpression {$left _ "|" _ $right(ExclusiveOrExpression) #BitwiseOr }*
ExclusiveOrExpression              = AndExpression {$left _ "^" _ $right(AndExpression) #BitwiseXor }*
AndExpression                      = EqualityExpression {$left _ "&" _ $right(EqualityExpression) #BitwiseAnd }*
EqualityExpression                 = RelationalExpression {$left _ ("==" #Equals / "!=" #NotEquals) _ $right(RelationalExpression) }*
relationalOperator                 = "<=" #LessThanEquals
                                   / ">=" #GreaterThanEquals
                                   / "<" #LessThan
                                   / ">" #GreaterThan
RelationalExpression               = ShiftExpression {$left _ relationalOperator _ $right(ShiftExpression) / _ "instanceof" _ $right(Type) #InstanceOf / _ "as" _ $right(Type) #As }*
ShiftExpression                    = AdditiveExpression {$left _ ("<<" #LeftShift / ">>" #ArithmeticRightShift / ">>>" #LogicalRightShift) _ $right(AdditiveExpression) }*
AdditiveExpression                 = MultiplicativeExpression {$left _ ("+" #Add / "-" #Sub) _ $right(MultiplicativeExpression) }*
MultiplicativeExpression           = CastNewExpression {$left _ ("*" #Mul / "/" #Div / "%" #Mod) _ $right(CastNewExpression) }*
CastNewExpression                  = { "(" $type(Type) ")" $expr(CastNewExpression) #Cast }
                                   / UnaryExpression
UnaryExpression                    = PostfixExpression
                                   / { "++" $expr(UnaryExpression) #PrefixInc }
                                   / { "--" $expr(UnaryExpression) #PrefixDec }
                                   / { "+" $expr(CastNewExpression) #Plus }
                                   / { "-" $expr(CastNewExpression) #Minus }
                                   / { "~" $expr(CastNewExpression) #Compl }
                                   / { "!" $expr(CastNewExpression) #Not }
PostfixExpression                  = PrimaryExpression {$ addMethodCall / addInstanceCreation / addIndex / addField / addInc / addDec }*
addMethodCall                      = "." $(TypeArguments)? $(Identifier) $(Arguments) #Method
addInstanceCreation                = "." "new" _ $(Type / Identifier) (_ $(TypeArguments))? _ $(Arguments) $(_ Block)? #InstanceCreation
addIndex                           = "[" $(Expression) "]" #Index
addField                           = "." $(Identifier) !'(' #Field
addInc                             = "++" #Inc
addDec                             = "--" #Dec
PrimaryExpression                  = Literal
                                   / "(" Expression ")"
                                   / InstanceCreationExpression
                                   / { "[" _ $(ArgumentList)? _ "]" #ArrayConstraction }
                                   / ClosureExp
                                   / Identifier
                                   / { "this" #This }
                                   / { $(Type) "." "this" #This }
                                   / AtExpression
                                   / Field
                                   / Type

InstanceCreationExpression         = { "new" _ $(TypeName) (_ $(TypeArguments))? _ $(Arguments) $(_ Block)? #InstanceCreation }

Field                              = { $({"super" #Super}) "." $(Identifier) #Field }
                                   / { $(Type) "." $({"super" #Super}) "." $(Identifier) #Field }

AtExpression                       = { "at" _ "(" _ $(Expression) _ ")" _ $(ClosureBody) #At }

ClosureExp                         = { $(Formals) (_ $(Guard))? (_ $(HasResultType)?) _ "=>" _ $(ClosureBody) #ClosureExpression }
ClosureBody                        = { $(Expression) #Body }
                                   / { $(Annotations)? _ $(Block) #Body }
example Expression ID
example Expression 1
example Expression this
example Expression super.ID
example Expression ID.ID(1, 1)
example Expression ID += 1
example Expression ID as Int
example Expression -ID
example Expression ~ID
example Expression ID + 1
example Expression ID - 1
example Expression ID * 1
example Expression ID / 1
example Expression ID % 1
example Expression ID << 1
example Expression ID >> 1
example Expression ID >>> 1
example Expression ID & 1
example Expression ID | 1
example Expression ID ^ 1
example Expression !ID
example Expression ID && 1
example Expression ID || 1
example Expression ID < 1
example Expression ID <= 1
example Expression ID > 1
example Expression ID >= 1
example Expression ID == 1
example Expression Int == Int
example Expression ID instanceof Int
example Expression (ID != 1) ? ID : ID
example Expression new Int()
example Expression ID.new ID()
example Expression new Int() {}
example Expression [1, 1, 1]
example Expression (ID : Int) => @A {}
example Expression at(this) ID


/* Identifiers */
IdentifierList            = { 'ID' #Stub }
Identifier                = { !KEYWORD [a-zA-Z_][a-zA-Z0-9_]* #Identifier }
                          / BackquotedIdentifier
BackquotedIdentifier      = {  [`] ( '\\' [`] / '\\' '\\' / ![\\`] .)+ [`]  #BackquotedIdentifier}

FullyQualifiedName        = { $(Identifier) (_ '.' _ $(Identifier) )* #FullyQualifiedName }

example Identifier Hoge_piyo
example Identifier Fuga1
example Identifier As
example Identifier `while`
example Identifier `0`
example Identifier `!`
example Identifier `(unbalanced(`
example Identifier '''
`\`\\`
'''


/* Literals */
Literal                   = NullLiteral / BooleanLiteral / IntLiteral / UByteLiteral / UShortLiteral / UIntLiteral / ULongLiteral / ShortLiteral / ByteLiteral / FloatLiteral /  DoubleLiteral / LongLiteral / CharacterLiteral / StringLiteral

/*Literal Shunsuke Takahashi*/
NullLiteral               = { "null" #Null }
BooleanLiteral            = { "true" #True }
                          / { "false" #False }

IntLiteral                = { SIGN? NUMERIC_LITERAL N #Int}

SIGN                      = '+'
                          / '-'
NUMERIC_LITERAL           = DECIMAL
                          / OCTA
                          / HEX
DECIMAL                   = [1-9] DIGIT*
DECIMAL2                  = [0-9] DIGIT*
DECIMALS                  = ([1-9] DIGIT*) / [0]
DIGIT                     = [0-9]
OCTA                      = '0' OCTA_NUM+
OCTA_NUM                  = [0-7]
HEX                       = ('0x' / '0X') HEX_NUM+
HEX_NUM                   = [A-Fa-f0-9]
N                         = 'n'
                          / 'N'

LongLiteral               = { SIGN? NUMERIC_LITERAL L? #Long }
L                         = 'l' / 'L'
UIntLiteral               = { NUMERIC_LITERAL UN #UInt }
UN                        = 'un' / 'nu' / 'UN' / 'NU'
ULongLiteral              = { NUMERIC_LITERAL ULONG #ULong }
ULONG                     = 'ul'/ 'lu' / 'UL' / 'LU' / 'u' / 'U'
ShortLiteral              = { NUMERIC_LITERAL S #Short }
S                         = 's' / 'S'
UShortLiteral             = { NUMERIC_LITERAL USHORT #UShort }
USHORT                    = 'us' / 'US'
ByteLiteral               = { NUMERIC_LITERAL BYTE #Byte }
BYTE                      = 'y' / 'Y'
UByteLiteral              = { NUMERIC_LITERAL UBYTE #Ubyte }
UBYTE                     = 'uy' / 'yu' / 'UY' / 'YU'
FloatLiteral              = { SIGN? F1 FF #Float }

FF                        = 'f' / 'F'
F1                        = B1 X?
B1                        = DECIMALS '.' DECIMAL2
                          / DECIMALS '.'
                          / '.' DECIMAL2
                          / DECIMALS
X                         = ( 'e' / 'E' ) SIGN? DECIMAL

F2                        = B2 X?
B2                        = DECIMALS '.' DECIMAL2
                          / DECIMALS '.'
                          / '.' DECIMAL2
                          / DECIMALS &('e'/'E'/'d'/'D') /*If double, dot or E/e must be in order to distingusih long*/

DoubleLiteral             = { SIGN? F2 D? #Double }
D                         = 'D' / 'd'
CharacterLiteral          = ['] { !['] CHARACTER_CONTENT #Char } [']
CHARACTER_CONTENT         = '\\b' / '\\t' / '\\n' / '\\f' / '\\r'/ '\\\'' / '\\"' / '\\' DD / '\\\\' / ![\\] .
DD                        = OCTA_NUM+
StringLiteral             = ["] { (!["] CHARACTER_CONTENT)* #String } ["]

example Literal true
example Literal false
example Literal null
example Literal 123n
example Literal -321N
example Literal 0123n
example Literal -0x123N
example Literal 0XEBECN
example Literal 1234567890
example Literal 0xBABEL
example Literal 123un
example Literal 0123un
example Literal 123u
example Literal 0xFU
example Literal 0xDecafC0ffeefU
example Literal 414S
example Literal 7001s
example Literal 0xBeaus
example Literal 50y
example Literal 0xbuy
example Literal 1f
example Literal 6.626068E-34F
example Literal 0.0
example Literal 0e100
example Literal 1.3d
example Literal 314159265e-8
example Literal '''
'c'
'''
example Literal '''
'\n'
'''
example Literal '''
""
'''
example Literal '''
"hello\040world!"
'''


/* Keywords and Operators */
KEYWORD                   = "abstract" / "as" / "assert" / "async" / "at"
                          / "athome" / "ateach" / "atomic" / "break" / "case"
                          / "catch" / "class" / "clocked" / "continue" / "def"
                          / "default" / "do" / "else" / "extends" / "false"
                          / "final" / "finally" / "finish" / "for" / "goto"
                          / "haszero" / "here" / "if" / "implements" / "import"
                          / "in" / "instanceof" / "interface" / "native" / "new"
                          / "null" / "offer" / "offers" / "operator" / "package"
                          / "private" / "property" / "protected" / "public" / "return"
                          / "self" / "static" / "struct" / "super" / "switch"
                          / "this" / "throw" / "transient" / "true" / "try"
                          / "type" / "val" / "var" / "void" / "when"
                          / "while" / "throws"
"abstract"                = 'abstract' !W
"as"                      = 'as' !W
"assert"                  = 'assert' !W
"async"                   = 'async' !W
"at"                      = 'at' !W
"athome"                  = 'athome' !W
"ateach"                  = 'ateach' !W
"atomic"                  = 'atomic' !W
"break"                   = 'break' !W
"case"                    = 'case' !W
"catch"                   = 'catch' !W
"class"                   = 'class' !W
"clocked"                 = 'clocked' !W
"continue"                = 'continue' !W
"def"                     = 'def' !W
"default"                 = 'default' !W
"do"                      = 'do' !W
"else"                    = 'else' !W
"extends"                 = 'extends' !W
"false"                   = 'false' !W
"final"                   = 'final' !W
"finally"                 = 'finally' !W
"finish"                  = 'finish' !W
"for"                     = 'for' !W
"goto"                    = 'goto' !W
"haszero"                 = 'haszero' !W
"here"                    = 'here' !W
"if"                      = 'if' !W
"implements"              = 'implements' !W
"import"                  = 'import' !W
"in"                      = 'in' !W
"instanceof"              = 'instanceof' !W
"interface"               = 'interface' !W
"native"                  = 'native' !W
"new"                     = 'new' !W
"null"                    = 'null' !W
"offer"                   = 'offer' !W
"offers"                  = 'offers' !W
"operator"                = 'operator' !W
"package"                 = 'package' !W
"private"                 = 'private' !W
"property"                = 'property' !W
"protected"               = 'protected' !W
"public"                  = 'public' !W
"return"                  = 'return' !W
"self"                    = 'self' !W
"static"                  = 'static' !W
"struct"                  = 'struct' !W
"super"                   = 'super' !W
"switch"                  = 'switch' !W
"this"                    = 'this' !W
"throw"                   = 'throw' !W
"transient"               = 'transient' !W
"true"                    = 'true' !W
"try"                     = 'try' !W
"type"                    = 'type' !W
"val"                     = 'val' !W
"var"                     = 'var' !W
"void"                    = 'void' !W
"when"                    = 'when' !W
"while"                   = 'while' !W
"throws"                  = 'throws' !W
"("                       = '('
")"                       = ')'
"{"                       = '{'
"}"                       = '}'
"["                       = '['
"]"                       = ']'
";"                       = ';'
","                       = ','
"."                       = '.' ![.]
"=="                      = '=='
"!="                      = '!='
"<"                       = '<' !( '-' / [:<=] )
">"                       = '>' !( '-' / [=>] )
"<="                      = '<='
">="                      = '>='
"&&"                      = '&&'
"||"                      = '||'
"&"                       = '&' ![&=]
"|"                       = '|' ![=|]
"^"                       = '^' ![=]
"<<"                      = '<<' ![=]
">>"                      = '>>' ![=>]
">>>"                     = '>>>' ![=]
"+"                       = '+' ![+=]
"-"                       = '-' !( '-' / [<=>] )
"*"                       = '*' ![*=]
"/"                       = '/' ![=]
"%"                       = '%' ![=]
"++"                      = '++'
"--"                      = '--'
"!"                       = '!' ![=~]
"~"                       = '~'
"&="                      = '&='
"|="                      = '|='
"^="                      = '^='
"<<="                     = '<<='
">>="                     = '>>='
">>>="                    = '>>>='
"+="                      = '+='
"-="                      = '-='
"*="                      = '*='
"/="                      = '/='
"%="                      = '%='
"="                       = '=' ![=>]
"?"                       = '?'
":"                       = ':' ![>]
"=>"                      = '=>'
"->"                      = '->'
"<:"                      = '<:'
":>"                      = ':>'
"@"                       = '@'
".."                      = '..'
"**"                      = '**'
"!~"                      = '!~'
"-<"                      = '-<'
">-"                      = '>-'
"<-"                      = '<-'

/* Integration Tests */
example File '''
package examples;

public class AsyncScope {
  public static def main(Rail[String]) {
    val val1 = 1;
    var var1:Int = 2;
    finish {
      val val2 = 3;
      var var2:Int = 4;
      async {
        val tmp1 = val1;  // ok
        val tmp2 = val2;  // ok
        val tmp3 = var1;  // ok
//        val tmp4 = var2;  // illegal
      }
      async {
        var1 = 5;         // ok
//        var2 = 6;         // illegal
      }
    }
  }
}
'''
example File '''
package examples;

public class Clocks {
  public static def main(Rail[String]) {
    clocked finish { // anonymous clock
      for(1..4) clocked async {
        Console.OUT.println("Phase 1");
        Clock.advanceAll();
        Console.OUT.println("Phase 2");
      }
    }

    finish { // named clock
      val c = Clock.make();
      for(1..4) async clocked(c) {
        Console.OUT.println("Phase 3");
        c.advance();
        Console.OUT.println("Phase 4");
      }
      c.drop();
    }
  }
}
'''
example File '''
package examples;

public class Fib {
  static def fib(n:Int):Int {
    if(n < 2) return n;
    val f1:Int;
    val f2:Int;
    finish {
      async f1 = fib(n-1);
      f2 = fib(n-2);
    }
    return f1 + f2;
  }

  public static def main(Rail[String]) {
    Console.OUT.println("fib(20)=" + fib(20));
  }
}
'''
example File '''
package examples;
import x10.io.Console;

public class Hello {                             // class
  protected val n:Long;                          // field

  public def this(n:Long) { this.n = n; }        // constructor

  public def test() = n > 0;                     // method

  public static def main(args:Rail[String]) {
    Console.OUT.println("Hello world! ");
    val foo = new Hello(args.size);              // inferred type
    var result:Boolean = foo.test();             // no inference for vars
    if(result) Console.OUT.println("The first arg is: " + args(0));
  }
}
'''
example File '''
package examples;

class HelloWholeWorld {
  public static def main(args:Rail[String]) {
    finish
    for(p in Place.places())
      at(p) async
        Console.OUT.println(p + " says " + args(0));
    Console.OUT.println("Bye");
  }
}
'''

