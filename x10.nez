/* Toplevel */
File                      = CompilationUnit
CompilationUnit           = { $(PackageDeclaration)? $(ImportDeclarations)? $(PackageDeclaration)? $(ImportDeclarations)? $(TypeDeclarations)? #Source }


/* Code layout */
_                         = ( WHITESPACE / BLOCKCOMMENT / LINECOMMENT )*
WHITESPACE                = [ \t\f\r\n]
BLOCKCOMMENT              = '/*' ( !'*/' . )* '*/'
LINECOMMENT               = '//' ( ![\r\n] . )*
W                         = [a-zA-Z_0-9]

/* Declarations */
PackageDeclaration        = { ( $(Annotations) _ )? "package" _ $(PackageName) #PackageDeclaration }
PackageName               = Id {$ _ "." _ $(Id) #PackageName }*
Id                        = Identifier
IdList                    = { $(Id) ( _ "." _ $(Id) )* #IdList }
ImportDeclarations        = { $(ImportDeclaration) ( _ $(ImportDeclaration) )* #ImportDeclarations }
ImportDeclaration         = { $(SingleTypeImportDecln) #ImportDeclaration }
                          / { $(TypeImportOnDemandDecln) #ImportDeclaration }
SingleTypeImportDecln     = { "import" _ $(TypeName) _ ";" #SingleTypeImportDecln }
TypeImportOnDemandDecln   = { "import" _ $(PackageOrTypeName) _ "." _ "*" _ ";" #TypeImportOnDemandDecln }
PackageOrTypeName         = Id {$ _ "." _ $(Id) #PackageOrTypeName }*
TypeDeclarations          = { $(TypeDeclaration) ( _ $(TypeDeclaration) )* #TypeDeclaration }
TypeDeclaration           = { $(ClassDeclaration) #TypeDeclaration}
                          / { $(StructDeclaration) #TypeDeclaration}
                          / { $(InterfaceDeclaration) #TypeDeclaration}
                          / { $(TypeDefDeclaration) #TypeDeclaration}
                          / { ';' #TypeDefDeclaration }
ClassDeclaration          = { ( $(Mods) _ )? "class" _ $(Id) ( _ $(TypeParametersI) )? ( _ $(Properties) )? ( _ $(Guard) )? ( _ $(Super) )? ( _ $(Interfaces) )? _ $(ClassBody) #ClassDeclaration }
StructDeclaration         = { ( $(Mods) _ )? "struct" _ $(Id) ( _ $(TypeParametersI) )? ( _ $(Properties) )? ( _ $(Guard) )? ( _ $(Interfaces) )? _ $(ClassBody) #StructDeclaration }
InterfaceDeclaration      = { ( $(Mods) _ )? "interface" _ $(Id) ( _ $(TypeParametersI) )? ( _ $(Properties) )? ( _ $(Guard) )? ( _ $(ExtendsInterfaces) )? _ $(InterfaceBody) #InterfaceDeclaration }
TypeDefDeclaration        = { ( $(Mods) _ )? "type" _ $(Id) ( _ $(TypeParameters) )? ( _ $(Guard) )? _ "=" _ $(Type) #TypeDefDeclaration }
                          / { ( $(Mods) _ )? "type" _ $(Id) ( _ $(TypeParameters) )? _ "(" _ $(FormalList) _ ")" ( _ $(Guard) )? _ $(Type) #TypeDefDeclaration }
MethodDeclaration         = { $(MethMods) _ "def" _ $(Id) ( _ $(TypeParameters) )? _ $(Formals) ( _ $(Guard) )? ( _ $(Throws) )? ( _ $(HasResultType) )? _ $(MethodBody) #MethodDeclaration }
                          / { $(BinOpDeclaration) #MethodDeclaration }
                          / { $(PrefixOpDeclatation) #MethodDeclaration }
                          / { $(ApplyOpDeclaration) #MethodDeclaration }
                          / { $(SetOpDeclaration) #MethodDeclaration }
                          / { $(ConversionOpDeclaration) #MethodDeclaration }
BinOpDeclaration          = { $(MethMods) _ "operator" ( _ $(TypeParameters) )? _ "(" _ $(Formal) _ ")" _ $(BinOp) _ "(" _ $(Formal) _ ")" ( _ $(Guard) )? ( _ $(HasResultType) )? _ $(MethodBody) #BinOpDeclaration }
                          / { $(MethMods) _ "operator" ( _ $(TypeParameters) )? _ "this" _ $(BinOp) _ "(" _ $(Formal) _ ")" ( _ $(Guard) )? ( _ $(HasResultType) )? _ $(MethodBody) #BinOpDeclaration }
                          / { $(MethMods) _ "operator" ( _ $(TypeParameters) )? _ "(" _ $(Formal) _ ")" _ $(BinOp) _ "this" ( _ $(Guard) )? ( _ $(HasResultType) )? _ $(MethodBody) #BinOpDeclaration }
PrefixOpDeclatation       = { $(MethMods) _ "operator" ( _ $(TypeParameters) )? _ $(PrefixOp) _ "(" _ $(Formal) _ ")" ( _ $(Guard) )? ( _ $(HasResultType) )? _ $(MethodBody) #PrefixOpDeclatation }
                          / { $(MethMods) _ "operator" ( _ $(TypeParameters) )? _ $(PrefixOp) _ "this" ( _ $(Guard) )? ( _ $(HasResultType) )? _ $(MethodBody) #PrefixOpDeclatation }
ApplyOpDeclaration        = { $(MethMods) _ "operator" _ "this" ( _ $(TypeParameters) )? _ $(Formals) ( _ $(Guard) )? ( _ $(HasResultType) )? _ $(MethodBody) #ApplyOpDeclaration }
SetOpDeclaration          = { $(MethMods) _ "operator" _ "this" ( _ $(TypeParameters) )? _ $(Formals) _ "=" _ "(" _ $(Formal) _ ")" ( _ $(Guard) )? ( _ $(HasResultType) )? _ $(MethodBody) #SetOpDeclaration }
ConversionOpDeclaration   = { $(ExplConvOpDeclaration) #ConversionOpDeclaration }
                          / { $(ImprConvOpDeclaration) #ConversionOpDeclaration }
ExplConvOpDeclaration     = { $(MethMods) _ "operator" ( _ $(TypeParameters) )? _ "(" _ $(Formal) _ ")" _ "as" _ $(Type) ( _ $(Guard) )? ( _ $(HasResultType) )? _ $(MethodBody) #ExplConvOpDeclaration }
                          / { $(MethMods) _ "operator" ( _ $(TypeParameters) )? _ "(" _ $(Formal) _ ")" _ "as" _ "?" ( _ $(Guard) )? ( _ $(HasResultType) )? _ $(MethodBody) #ExplConvOpDeclaration }
ImprConvOpDeclaration     = { $(MethMods) _ "operator" ( _ $(TypeParameters) )? _ "(" _ $(Formal) _ ")" ( _ $(Guard) )? ( _ $(HasResultType) )? _ $(MethodBody) #ImprConvOpDeclaration }
ConstructorDeclaration    = { ( $(Mods) _ )? "def" _ "this" ( _ $(TypeParameters) )? ( _ $(Formals) )? ( _ $(Guard) )? ( _ $(HasResultType) )? _ $(ConstructorBody) #ConstructorDeclaration }
PropertyMethodDeclaration = { $(MethMods) _ $(Id) ( _ $(TypeParameters) )? _ $(Formals) ( _ $(Guard) )? ( _ $(HasResultType) )? _ $(MethodBody) #PropertyMethodDeclaration }
                          / { $(MethMods) _ $(Id) ( _ $(Guard) )? ( _ $(HasResultType) )? _ $(MethodBody) #PropertyMethodDeclaration }
FieldDeclaration          = { ( $(Mods) _ )? $(VarKeyword) _ $(FieldDeclrs) _ ";" #FieldDeclaration }
                          / { ( $(Mods) _ )? $(FieldDeclrs) _ ";" #FieldDeclaration }
FieldDeclrs               = { $(FieldDeclr) ( _ "," _ $(FieldDeclr) )* #FieldDeclrs }
FieldDeclr                = { $(Id) ( _ $(HasResultType) )? _ "=" _ $(VariableInitializer) #FieldDeclr }
                          / { $(Id) _ $(HasResultType) #FieldDeclr }

VariableInitializer       = { $(Expression) #VariableInitializer }
LocalVariableDeclaration  = { ( $(Mods) _ )? $(VarKeyword) _ $(VariableDeclarations) #LocalVariableDeclaration }
                          / { ( $(Mods) _ )? _ $(VariableDeclarationsWType) #LocalVariableDeclaration }
                          / { ( $(Mods) _ )? $(VarKeyword) _ $(FormalDeclarations) #LocalVariableDeclaration }
VariableDeclarations      = { $(VariableDeclaration) ( _ "," _ $(VariableDeclaration) )* #VariableDeclarations }
VariableDeclaration       = { $(Id) ( _ $(HasResultType) )? _ "=" _ $(VariableInitializer) #VariableDeclaration }
                          / { "[" _ $(IdList) _ "]" ( _ $(HasResultType) )? _ "=" _ $(VariableInitializer) #VariableDeclaration }
                          / { $(Id) _ "[" _ $(IdList) _ "]" ( _ $(HasResultType) )? _ "=" _ $(VariableInitializer) #VariableDeclaration }
VariableDeclarationsWType = { $(VariableDeclarationWType) ( _ "," _ $(VariableDeclarationWType) )* #VariableDeclarationsWType }
VariableDeclarationWType  = { $(Id) _ $(HasResultType) _ "=" _ $(VariableInitializer) #VariableDeclaration }
                          / { "[" _ $(IdList) _ "]" _ $(HasResultType) _ "=" _ $(VariableInitializer) #VariableDeclaration }
                          / { $(Id) _ "[" _ $(IdList) _ "]" _ $(HasResultType) _ "=" _ $(VariableInitializer) #VariableDeclaration }
FormalDeclarations        = { $(FormalDeclaration) ( _ "," _ $(FormalDeclaration) )* #FormalDeclarations }
FormalDeclaration         = { $(Id) _ $(ResultType) #FormalDeclaration }
                          / { "[" _ $(IdList) _ "]" _ $(ResultType) #FormalDeclaration }
                          / { $(Id) _ "[" _ $(IdList) _ "]" _ $(ResultType) #FormalDeclaration }
LoopIndex                 = { ( $(Mods) _ )? $(LoopIndexDeclaration) #LoopIndex }
                          / { ( $(Mods) _ )? $(VarKeyword) _ $(LoopIndexDeclaration) #LoopIndex }
LoopIndexDeclaration      = { $(Id) ( _ $(HasResultType) )? #LoopIndexDeclaration }
                          / { "[" _ $(IdList) _ "]" ( _ $(HasResultType) )? #LoopIndexDeclaration }
                          / { $(Id) _ "[" _ $(IdList) _ "]" ( _ $(HasResultType) )? #LoopIndexDeclaration }
Mods                      = { $(Mod) ( _ $(Mod) )* #Mods }
Mod                       = Annotation
                          / "abstract" { #Abstract }
                          / "atomic" { #Atomic }
                          / "final" { #Final }
                          / "native" { #Native }
                          / "private" { #Private }
                          / "protected" { #Protected }
                          / "public" { #Public }
                          / "static" { #Static }
                          / "transient" { #Transient }
                          / "clocked" { #Clocked }
MethMods                  = ( Mods / "property" { #Property } / Mod ) {$ _ ( "property" / $(Mod) ) #MethMods }*
Properties                = { "(" _ $(PropList) _ ")" #Properties }
PropList                  = { $(Prop) ( _ "," _ $(Prop) )* #PropList }
Prop                      = { ( $(Annotations) _ )? $(Id) _ $(ResultType) #Prop }
ResultType                = { ":" _ $(Type) #ResultType }
Super                     = { "extends" _ $(ClassType) #Super }
Interfaces                = { "implements" _ $(InterfaceTypeList) #Interfaces }
ClassBody                 = { "{" ( _ $(ClassMemberDeclaration) )? _ "}"}
ClassMemberDeclaration    = { $(InterfaceMemberDecln) #ClassMemberDeclaration }
                          / { $(ConstructorDeclaration) #ClassMemberDeclaration }
ConstructorBody           = { $(ConstructorBlock) #ConstructorBody }
                          / { "=" _ $(ExplicitCtorInvo) #ConstructorBody }
                          / { "=" _ $(AssignPropCall) #ConstructorBody }
                          / ";" { #ConstructorBody }
ConstructorBlock          = { "{" ( _ $(ExplicitCtorInvo) )? ( _ _BlockStatements )? _ "}" #ConstructorBlock }
ExplicitCtorInvo          = { "this" ( _ $(TypeArguments) )? _ "(" ( _ $(ArgumentList) )? _ ")" _ ";" #ExplicitCtorInvo }
                          / { "super" ( _ $(TypeArguments) )? _ "(" ( _ $(ArgumentList) )? _ ")" _ ";" #ExplicitCtorInvo }
                          / { $(PrimaryExpression) _ "." _ "this" ( _ $(TypeArguments) )? _ "(" ( _ $(ArgumentList) )? _ ")" _ ";" #ExplicitCtorInvo }
                          / { $(PrimaryExpression) _ "." _ "super" ( _ $(TypeArguments) )? _ "(" ( _ $(ArgumentList) )? _ ")" _ ";" #ExplicitCtorInvo }
AssignPropCall            = { "property" ( _ $(TypeArguments) )? _ "(" ( _ $(ArgumentList) )? _ ")" _ ";" #AssignPropCall }
ExtendsInterfaces         = "extends" _ Type {$ _ "," _ $(Type) #ExtendsInterfaces }
InterfaceBody             = { "{" ( _ $(InterfaceMemberDeclns) )? _ "}" #InterfaceBody }
InterfaceMemberDeclns     = { $(InterfaceMemberDecln) ( _ $(InterfaceMemberDecln) )* #InterfaceMemberDeclns }
InterfaceMemberDecln      = { $(MethodDeclaration) #InterfaceMemberDecln }
                          / { $(PropertyMethodDeclaration) #InterfaceMemberDecln }
                          / { $(FieldDeclaration) #InterfaceMemberDecln }
                          / { $(TypeDeclaration) #InterfaceMemberDecln }
FormalList                = { $(Formal) ( _ "," _ $(Formal) )* #FormalList }
Formals                   = { "(" ( _ $(FormalList) )? _ ")" #Formals }
Formal                    = { ( $(Mods) _ )? $(FormalDeclaration) #Formal }
                          / { ( $(Mods) _ )? $(VarKeyword) _ $(FormalDeclaration) #Formal }
                          / { $(Type) #Formal }
VarKeyword                = "val" { #Val }
                          / "var" { #Var }
FormalDeclaration         = { $(Id) _ $(ResultType) #FormalDeclaration }
                          / { "[" _ $(IdList) _ "]" _ $(ResultType) #FormalDeclaration }
                          / { $(Id) _ "[" _ $(IdList) _ "]" _ $(ResultType) #FormalDeclaration }
Guard                     = { $(DepParams) #Guard }
Throws                    = { "throws" _ $(ThrowList) #Throws }
ThrowList                 = { $(Type) ( _ "," _ $(Type) )? #ThrowList }
HasResultType             = { $(ResultType) #HasResultType }
                          / { "<:" _ $(Type) #HasResultType }
MethodBody                = { "=" _ $(LastExp) _ ";" #MethodBody }
                          / { ( $(Annotations) _ )? $(Block) #MethodBody }
                          / { ";" #MethodBody }
LastExp                   = { $(Expression) #LastExp }
BinOp                     = { (
                          "+"
                          / "-"
                          / "*"
                          / "/"
                          / "%"
                          / "&"
                          / "|"
                          / "^"
                          / "&&"
                          / "||"
                          / "<<"
                          / ">>"
                          / ">>>"
                          / ">="
                          / "<="
                          / ">"
                          / "<"
                          / "=="
                          / "!="
                          / ".."
                          / "->"
                          / "<-"
                          / "-<"
                          / ">-"
                          / "**"
                          / "~"
                          / "!~"
                          / "!"
                          ) #BinOp }
PrefixOp                  = { (
                          "+"
                          / "-"
                          / "!"
                          / "~"
                          / "^"
                          / "|"
                          / "&"
                          / "*"
                          / "/"
                          / "%"
                          ) #PrefixOp }

example PackageDeclaration '''
package ID.ID;
'''
example ImportDeclarations '''
import Int;
import ID.ID.*;
'''
example TypeDeclaration '''
class ID extends Int implements Int, Int {}
'''
example TypeDeclaration '''
struct ID {}
'''
example TypeDeclaration '''
interface ID extends Int, Int {}
'''
example MethodDeclaration '''
public def ID(ID : Int) : Int {}
'''
example MethodDeclaration '''
public operator !(ID : Int) {}
'''
example PropertyMethodDeclaration '''
property ID(ID : Int) = exp;
'''
example ConstructorDeclaration '''
def this(ID : Int) {}
'''
example ConstructorDeclaration '''
def this(ID : Int) = this();
'''
example ConstructorDeclaration '''
def this(ID : Int) = exp.super();
'''
example FieldDeclaration '''
private var ID : Int = exp;
'''
example LocalVariableDeclaration '''
var ID : Int = exp
'''
example LocalVariableDeclaration '''
val ID = exp
'''
example LocalVariableDeclaration '''
var ID : Int
'''


/* Types */
Type                      = { ( $(FunctionType) / $(NamedType) / $(Void) ) $(Annotations)* #Type }

FunctionType              = { $(TypeParameters)? _ $(Formals) _ $(Guard)? _ '=>' _ $(Type) _ #FunctionType }

DepParams                 = '{' _ Expression _ '}'

Annotation                = { '@' $(NamedTypeNoConstraints) #Annotation }

//ConstrainedType           = NamedType / AnnotatedType

Void                      = { 'void' #Void }

Annotations               = { $(Annotation)+ }

ClassType                 = NamedType

ThrowsList                = { Type _ ( ',' _ Type )* #ThrowsList }

InterfaceTypeList         = { Type _ ( ',' _ Type )* #InterfaceTypeList }


//AnnotatedType             = { $(Type) $(Annotations) #AnnotatedType }

TypeArguments             = { '[' $(TypeArgumentList) ' ]' #TypeArguments }

TypeArgumentList          = { $(Type) ( ',' $(Type) )* }

TypeParameters            = { '[' $(TypeParamList) ']' #TypeParameters }
TypeParametersI           = { '[' $(TypeParamIList) ']' #TypeParametersI }

TypeParamIList            =　{ $(TypeParam) _ ( ',' _ $(TypeParam) )* _ ','? }

TypeParamList             = { $(TypeParam) _ ( ',' _ $(TypeParam) )* }

TypeParam                 = { $(Id) #TypeParam }

TypeName                  = { $(Id) ( '.' $(Id) )* #TypeName }

NamedType                 = { $(NamedTypeNoConstraints ) }
			  / DepNamedType

NamedTypeNoConstraints    = { $(ParamizedNamedType) }
			  / { $(SimpleNamedType) }

SimpleNamedType           = { $(TypeName) }
			  / { $(PrimaryExpression) '.' $(Id) }
			  / { $(ParamizedNamedType) '.' $(Id) }
			  / { $(DepNamedType) '.' $(Id) }

ParamizedNamedType        = { $(TypeName) $(TypeParameters) }

			  
DepNamedType              = { ( $(TypeName) / $(PrimaryExpression) '.' $(Id) / $(ParamizedNamedType) '.' $(Id) ) ( '.' $(Id) $(DepParams) )* }
			  / { $(ParamizedNamedType) $(DepParams) }



example Type Int
example Type ID[ID]
example Type ID[ID,ID]
example Type ID.ID
example Type (ID : Int) => Int


/* Statements */
_BlockStatements          = _ ($(BlockInteriorStatement) _ ( _ $(BlockInteriorStatement))* ) _

Block                     = { "{" _ $(BlockStatements)?  "}" _ #Block }
BlockStatements                = { _ ($(BlockInteriorStatement) _ ( _ $(BlockInteriorStatement))* ) _ #BlockStatements}
BlockInteriorStatement    = LocalVariableDeclarationStatement
                          / ClassDeclaration
                          / StructDeclaration
                          / TypeDefDeclaration
                          / Statement

Statement                 = Block
                          / EmptyStatement
                          / LocalVariableDeclarationStatement
                          / ExpressionStatement
                          / LabeledStatement
                          / BreakStatement
                          / ContinueStatement
                          / IfThenStatement
                          / IfThenElseStatement
                          / SwitchStatement
                          / WhileStatement
                          / DoStatement
                          / ForStatement
                          / ReturnStatement
                          / AssertStatement
                          / ThrowStatement
                          / TryStatement
                          / AsyncStatement
                          / FinishStatement
                          / AtEachStatement
                          / AtStatement
                          / AtomicStatement
                          / WhenStatement

EmptyStatement =  {";" #EmptyStatement}

LocalVariableDeclarationStatement = { $(LocalVariableDeclaration) _ ";" _ #LocalVariableDeclarationStatement}

ExpressionStatement = StatementExpression

LabeledStatement = {$(Identifier) _ ':' _ $(Statement) #LabeledStatement}

BreakStatement = {"break" _ $(Identifier)? _ #BreakStatement}

ContinueStatement = {"continue" _ $(Identifier)? #ContinueStatement}

IfThenStatement = {"if" _ "(" _ $(Expression) _ ")" _ $(Statement) #IfThenStatement}
IfThenElseStatement = {"if" _ "(" _ $(Expression) _ ")" _ $(Statement) _ "else" _ $(Statement) #IfThenElseStatement}

SwitchStatement = {"switch" _ "(" _ $(Expression) _ ")" _ $(SwitchBlock) _ #SwitchStmt}
SwitchBlock = {"{" _ $(SwitchBlockGroups)? _ $(SwitchLabels)? _ "}" _ #SwitchBlock}
SwitchBlockGroups = { $(SwitchBlockGroup) _ (_ $(SwitchBlockGroup) _ )* _ #SwitchBlockGroups}
SwitchBlockGroup = {$(SwitchLabels) _ $(BlockStatements) _ #SwitchBlockGroup}
SwitchLabels = { $(SwitchLabel) _ (_ $(SwitchLabel) _)* _ #SwitchLabels}
SwitchLabel = {(_ "case" _ $(ConstantExpression) _ ":" _)
             / (_ "default" _ ":" _) #SwitchLabel}
ConstantExpression = Expression

WhileStatement = {"while" _ "(" _ $(Expression) _ ")" _ $(Statement) #WhileStatement}


DoStatement = {"do" _ $(Statement) _ "while" _ "(" _ $(Expression) _ ")" #DoStatement}

ForStatement = BasicForStatement
        / EnhancedForStatement
BasicForStatement = {"for" _ "(" _ $(ForInit)? _ ";" _ $(Expression)? _ ";" _ $(ForUpdate)? _ ")" _ $(Statement) #BasicForStatement}
ForInit = StatementExpressionList
        / LocalVariableDeclaration
ForUpdate = StatementExpressionList
EnhancedForStatement = {("for" _ "(" _ $(LoopIndex) _ "in" _ $(Expression) _ ")" _ $(Statement))
                / ("for" _ "(" _ $(Expression) _ ")" _ $(Statement)) #EnhancedForStatement}

ReturnStatement = {"return" _ $(Expression)? #ReturnStatement}


AssertStatement = {("assert" _ $(Expression)) _ (":" _ $(Expression))? #AssertStatement}

ThrowStatement = {"throw" _ $(Expression) #ThrowStatement}

TryStatement = {("try" _ $(Block) _ $(Catches) _ )
        / ("try" _ $(Block) _ $(Catches)? _ $(Finally)) #TryStmt}
Catches = { _ $(CatchClause)  _ ( _ $(CatchClause))* _ #Catches}
CatchClause = { _ "catch" _ "(" _ $(Formal) _ ")" _ $(Block) _ #CatchClause}
Finally = { _ "finally" _ $(Block) #Finally}

AsyncStatement = {("async" _ $(ClockedClause)? _ $(Statement))
          / ("clocked" _ "async" _ $(Statement)) #AsyncStmt}
ClockedClause = {"clocked" _ $(Arguments) _  #ClockedClause}

FinishStatement = {("finish" _ $(Statement))
            / ("clocked" _ "finish" _ $(Statement)) #FinishStmt}

AtEachStatement = {("ateach" _ "(" _ $(LoopIndex) _ "in" _ $(Expression) _ ")" _ $(ClockedClause)? _ $(Statement))
            / ("ateach" _ "(" _ $(Expression) _ ")" _ $(Statement)) #AtEachStmt}

AtStatement = { "at" _ "(" _ $(Expression) _  ")" _ $(Statement) #AtStatement}

AtomicStatement = {"atomic" _ $(Statement) #AtomicStmt}
WhenStatement = {"when" _ "(" _ $(Expression) _ ")" _ $(Statement) #WhenStmt}

example Block {}
example Block '''
{
  class X{}
  var x = 1;
}
'''
example Statement ;
example Statement {}
example Statement exp++;
example Statement break;
example Statement break ID;
example Statement continue;
example Statement if(exp) break;
example Statement while(exp) {}
example Statement do {} while(exp);
example Statement for(var x = 1; exp; exp++) {}
example Statement return exp;
example Statement ID : while(exp) {}
example Statement assert exp;
example Statement assert exp : exp;
example Statement throw exp;
example Statement '''
switch(exp) {
    case exp : break;
    case exp : break;
    default : break;
}
'''
example Statement '''
try {
} catch (ID : Int) {
} catch (ID : Int) {
}
'''
example Statement '''
try {
} finally {
}
'''
example Statement at(exp) {}
example Statement async {}
example Statement async clocked(exp) {}
example Statement clocked async {}
example Statement finish {}
example Statement clocked finish {}
example Statement ateach(li in exp) {}
example Statement ateach(exp) {}
example Statement atomic {}
example Statement when(exp) {}


/* Expressions */
Arguments                 = { "(" (_ ArgumentList)? _ ")" #Arguments }

StatementExpressionList   = { $(StatementExpression)  (_ "," _ $(StatementExpression))* #StatementExpressionList }
StatementExpression       = Assignment
                          / UnaryExpression
Expression                = Assignment
                          / {Type _ ("<:" #Subtyping / ":>" #Subtyped) Type}
ArgumentList              = { $(Expression) (_ "," _ $(Expression))* #List}
Assignment                = {($left(PrimaryExpression / Identifier) _ "(" _ $(ArgumentList)? _ ")" / $left(LeftHandSide)) _ AsstOp _ $right(Expression)}
                          / ConstantExpression
LeftHandSide              = FieldAccess / Identifier
AsstOp                    = "=" #Assign
                          / "*=" #AssignMul
                          / "/=" #AssignDiv
                          / "%=" #AssignMod
                          / "+=" #AssignAdd
                          / "-=" #AssignSub
                          / "<<=" #AssignLeftShift
                          / ">>=" #AssignRightShift
                          / ">>>=" #AssignLogicalRightShift
                          / "&=" #AssignBitwiseAnd
                          / "^=" #AssignBitwiseXOr
                          / "|=" #AssignBitwiseXOr
ConstantExpression        = ConditionalExpression
ConditionalExpression     = LogicalOrExpression {$cond _ "?" _ $then(Expression) _ ":" _ $else(LogicalOrExpression) #Conditional }*
LogicalOrExpression       = LogicalAndExpression {$left _ "||" _ $right(LogicalAndExpression) #Or }*
LogicalAndExpression      = EqualityExpression {$left _ "&&" _ $right(EqualityExpression) #And }*
EqualityExpression        = RelationalExpression {$left _ ("==" #Equals / "!=" #NotEquals) _ $right(RelationalExpression) }*
                          / Type {$left _ ("==" #Equals / "!=" #NotEquals) _ $right(Type) }*
relationalOperator        = "<=" #LessThanEquals
                          / ">=" #GreaterThanEquals
                          / "<" #LessThan
                          / ">" #GreaterThan
RelationalExpression      = BitwiseOrExpression {$left _ relationalOperator _ $right(BitwiseOrExpression) / _ "instanceof" _ $right(Type) #InstanceOf }*
BitwiseOrExpression       = BitwiseAndExpression {$left _ "|" _ $right(BitwiseAndExpression) #BitwiseOr }*
BitwiseAndExpression      = BitwiseXOrExpression {$left _ "&" _ $right(BitwiseXOrExpression) #BitwiseAnd }*
BitwiseXOrExpression      = ShiftExpression {$left _ "^" _ $right(ShiftExpression) #BitwiseXOr }*
ShiftExpression           = AdditiveExpression {$left _ ("<<" #LeftShift / ">>" #ArithmeticRightShift / ">>>" #LogicalRightShift) _ $right(AdditiveExpression) }*
AdditiveExpression        = MultiplicativeExpression {$left _ ("+" #Add / "-" #Sub) _ $right(MultiplicativeExpression) }*
MultiplicativeExpression  = CastNewExpression {$left _ ("*" #Mul / "/" #Div / "%" #Mod) _ $right(CastNewExpression) }*
CastNewExpression         = NumericOperation / UnaryExpression
NumericOperation          = { $(Identifier / Literal) _ "as" _ $(Type) #As}
UnaryExpression           = PostfixExpression
                          / { "++" $expr(UnaryExpression) #PreInc }
                          / { "--" $expr(UnaryExpression) #PreDec }
                          / { "+" $expr(CastNewExpression) #Plus }
                          / { "-" $expr(CastNewExpression) #Minus }
                          / { "~" $expr(CastNewExpression) #BitwiseComplement }
                          / { "!" $expr(CastNewExpression) #LogicalNot }
                          / { "new" _ ($name(Identifier) / $type(Type)) $(_ TypeArguments)? _ $({ "(" _ (ArgumentList _)? ")" #List }) $(_ ClassBody)? #New}
                          / { "at" "(" $expr(Expression) ")" _ $(Identifier) #At }
PostfixExpression         = PrimaryExpression {$ addMethodInvo / addInstanceCreation / addFieldAccess / addInc / addDec}*
PrimaryExpression         = { ("this" / $(ClassName) "." "this") #This }
                          / {"super" #Super}
                          / "(" _ Expression _ ")"
                          / {"["_ (addArgumentExpressionList _ )? "]" #Array}
                          / ClosureExp
                          / Identifier
                          / Literal
addInc                    = "++" #Inc
addDec                    = "--" #Dec
addMethodInvo             = "." $(Identifier) _ $(TypeArguments _)? $({ "(" _ (addArgumentExpressionList _)? ")" #List }) #Calls
addFieldAccess            = "." $(Identifier) !'(' #Field
addInstanceCreation       = "." "new" _ $(Identifier) $(_ TypeArguments)? _ $({ "(" _ (addArgumentExpressionList _)? ")" #List }) $(_ ClassBody)? #InstanceCreation
addArgumentExpressionList = $(Expression) (_ "," _ $(Expression) )*
FieldAccess               = { (
                            $(PrimaryExpression) "." $(Identifier)
                          / $({ "super" #Super}) "." $(Identifier)
                          / $(ClassName) "." $({ "super" #Super}) $(Identifier)
                          ) #FieldAccess }
ClassName                 = Identifier
MethodName                = {$(FullyQualifiedName) "." $(Identifier) #Field} / Identifier
ClosureExp                = { $(Formals) _ $(Guard)? _ $(HasResultType)? _ "=>" _ ClosureBody #Closure}
ClosureBody               = $(Expression)
                          / $(Annotations)? _ $(Block)

example Expression ID
example Expression 1
example Expression this
example Expression super.ID
example Expression ID.ID(1, 1)
example Expression ID += 1
example Expression ID as Int
example Expression -ID
example Expression ~ID
example Expression ID + 1
example Expression ID - 1
example Expression ID * 1
example Expression ID / 1
example Expression ID % 1
example Expression ID << 1
example Expression ID >> 1
example Expression ID >>> 1
example Expression ID & 1
example Expression ID | 1
example Expression ID ^ 1
example Expression !ID
example Expression ID && 1
example Expression ID || 1
example Expression ID < 1
example Expression ID <= 1
example Expression ID > 1
example Expression ID >= 1
example Expression ID == 1
example Expression Int == Int
example Expression ID instanceof Int
example Expression (ID != 1) ? ID : ID
example Expression new Int()
example Expression ID.new ID()
example Expression new Int() {}
example Expression [1, 1, 1]
example Expression (ID : Int) => @A {}
example Expression at(this) ID


/* Identifiers */
IdentifierList            = { 'ID' #Stub }

Identifier                = {  '`' $(AnyString) '`' / !$(KEYWORD) $(FullyQualifiedName)  #Identifier }
AnyString                 = { ( '\\' ( '\\' / '`' ) / !'`' . )* #AnyString }

FullyQualifiedName        = { [a-zA-Z_][a-zA-Z_0-9]* #FullyQualifiedName }

example Identifier Hoge_piyo
example Identifier Fuga1
example Identifier As
example Identifier `while`
example Identifier `0`
example Identifier `!`
example Identifier `(unbalanced(`
example Identifier '''
`\`\\`
'''


/* Literals */
Literal = boolean
        / self
        / Int
        / UInt
        / UShort
        / UByte
        / ULong
        / Short
        / Byte
        / Float
        / Long
        / Double
        / String
        / Char

boolean = {'true' #boolean}
        / {'false' #boolean}

d = '0'
  / [1-9][0-9]*

d8 = '0'
   / [1-7][0-7]*

d16 = '0'
    / [1-9A-Fa-f][0-9A-Fa-f]*

i = '0' d8
  / '0' ('x' / 'X') d16
  / d

s = '+' / '-'
b = d '.' d
  / d '.'
  / d
  / '.' d

x = ('e' / 'E') s d

f = b x?

self = {'null' #null}

Int = { s? i ('n' / 'N') #Int}

Long = { s? i ('l'/'L') #Long}
     / { s? i !('.' / 'e') #Long}

UInt = { i ('un' / 'nu' / 'UN' / 'NU') #UInt}

ULong = { i ('u' / 'ul' / 'lu' / 'U' / 'UL' / 'LU') #ULong}

Short = { s? i ('s' / 'S') #Short}

UShort = { i ('us' / 'su' / 'SU' / 'US') #UShort}

Byte = { s? i ('y' / 'Y') #Byte}

UByte = { i ('uy' / 'yu' / 'UY' / 'YU') #UByte}

Float = { s? f ('f' / 'F') #Float}

Double = { s? f ('d' / 'D') #Double}
       / { s? f 'e' s? d #Double}
       / { s? f #Double}


Char = { ['] CharacterContents ['] #Char }

CharacterContents = !['"\\].
                  / '\\' 'b'
                  / '\\' 't'
                  / '\\' 'n'
                  / '\\' 'f'
                  / '\\' 'r'
                  / '\\' [']
                  / '\\' '"'
                  / '\\' '\\'
                  / '\\' dd

dd = '0' [0-3]* [0-7]* [0-7]*


String = { '"' CharacterContents* '"' #String}

example Literal true
example Literal false
example Literal null
example Literal 123n
example Literal -321N
example Literal 0123n
example Literal -0x123N
example Literal 0XEBECN
example Literal 1234567890
example Literal 0xBABEL
example Literal 123un
example Literal 0123un
example Literal 123u
example Literal 0xFU
example Literal 0xDecafC0ffeefU
example Literal 414S
example Literal 7001s
example Literal 0xBeaus
example Literal 50y
example Literal 0xbuy
example Literal 1f
example Literal 6.626068E-34F
example Literal 0.0
example Literal 0e100
example Literal 1.3d
example Literal 314159265e-8
example Literal '''
'c'
'''
example Literal '''
'\n'
'''
example Literal '''
""
'''
example Literal '''
"hello\040world!"
'''


/* Keywords and Operators */
KEYWORD                   = "abstract" / "as" / "assert" / "async" / "at"
                          / "athome" / "ateach" / "atomic" / "break" / "case"
                          / "catch" / "class" / "clocked" / "continue" / "def"
                          / "default" / "do" / "else" / "extends" / "false"
                          / "final" / "finally" / "finish" / "for" / "goto"
                          / "haszero" / "here" / "if" / "implements" / "import"
                          / "in" / "instanceof" / "interface" / "native" / "new"
                          / "null" / "offer" / "offers" / "operator" / "package"
                          / "private" / "property" / "protected" / "public" / "return"
                          / "self" / "static" / "struct" / "super" / "switch"
                          / "this" / "throw" / "transient" / "true" / "try"
                          / "type" / "val" / "var" / "void" / "when"
                          / "while" / "throws"
"abstract"                = 'abstract' !W
"as"                      = 'as' !W
"assert"                  = 'assert' !W
"async"                   = 'async' !W
"at"                      = 'at' !W
"athome"                  = 'athome' !W
"ateach"                  = 'ateach' !W
"atomic"                  = 'atomic' !W
"break"                   = 'break' !W
"case"                    = 'case' !W
"catch"                   = 'catch' !W
"class"                   = 'class' !W
"clocked"                 = 'clocked' !W
"continue"                = 'continue' !W
"def"                     = 'def' !W
"default"                 = 'default' !W
"do"                      = 'do' !W
"else"                    = 'else' !W
"extends"                 = 'extends' !W
"false"                   = 'false' !W
"final"                   = 'final' !W
"finally"                 = 'finally' !W
"finish"                  = 'finish' !W
"for"                     = 'for' !W
"goto"                    = 'goto' !W
"haszero"                 = 'haszero' !W
"here"                    = 'here' !W
"if"                      = 'if' !W
"implements"              = 'implements' !W
"import"                  = 'import' !W
"in"                      = 'in' !W
"instanceof"              = 'instanceof' !W
"interface"               = 'interface' !W
"native"                  = 'native' !W
"new"                     = 'new' !W
"null"                    = 'null' !W
"offer"                   = 'offer' !W
"offers"                  = 'offers' !W
"operator"                = 'operator' !W
"package"                 = 'package' !W
"private"                 = 'private' !W
"property"                = 'property' !W
"protected"               = 'protected' !W
"public"                  = 'public' !W
"return"                  = 'return' !W
"self"                    = 'self' !W
"static"                  = 'static' !W
"struct"                  = 'struct' !W
"super"                   = 'super' !W
"switch"                  = 'switch' !W
"this"                    = 'this' !W
"throw"                   = 'throw' !W
"transient"               = 'transient' !W
"true"                    = 'true' !W
"try"                     = 'try' !W
"type"                    = 'type' !W
"val"                     = 'val' !W
"var"                     = 'var' !W
"void"                    = 'void' !W
"when"                    = 'when' !W
"while"                   = 'while' !W
"throws"                  = 'throws' !W
"("                       = '('
")"                       = ')'
"{"                       = '{'
"}"                       = '}'
"["                       = '['
"]"                       = ']'
";"                       = ';'
","                       = ','
"."                       = '.' ![.]
"=="                      = '=='
"!="                      = '!='
"<"                       = '<' !( '-' / [:<=] )
">"                       = '>' !( '-' / [=>] )
"<="                      = '<='
">="                      = '>='
"&&"                      = '&&'
"||"                      = '||'
"&"                       = '&' ![&=]
"|"                       = '|' ![=|]
"^"                       = '^' ![=]
"<<"                      = '<<' ![=]
">>"                      = '>>' ![=>]
">>>"                     = '>>>' ![=]
"+"                       = '+' ![+=]
"-"                       = '-' !( '-' / [<=>] )
"*"                       = '*' ![*=]
"/"                       = '/' ![=]
"%"                       = '%' ![=]
"++"                      = '++'
"--"                      = '--'
"!"                       = '!' ![=~]
"~"                       = '~'
"&="                      = '&='
"|="                      = '|='
"^="                      = '^='
"<<="                     = '<<='
">>="                     = '>>='
">>>="                    = '>>>='
"+="                      = '+='
"-="                      = '-='
"*="                      = '*='
"/="                      = '/='
"%="                      = '%='
"="                       = '=' ![=>]
"?"                       = '?'
":"                       = ':' ![>]
"=>"                      = '=>'
"->"                      = '->'
"<:"                      = '<:'
":>"                      = ':>'
"@"                       = '@'
".."                      = '..'
"**"                      = '**'
"!~"                      = '!~'
"-<"                      = '-<'
">-"                      = '>-'
"<-"                      = '<-'

